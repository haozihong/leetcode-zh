class Solution1 {  // try deleting each node
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<vector<int>> tb(n);
        for (int i=0; i<n; ++i)
            for (int j=0; j<n; ++j)
                if (j != i && graph[i][j]) tb[i].push_back(j);
        int mn = n, mni = -1;
        vector<int> que;
        vector<bool> seen(n);
        for (auto &i : initial) {
            que.clear();
            fill(begin(seen), end(seen), false);
            for (auto &j : initial)
                if (j != i) que.push_back(j), seen[j] = true;
            for (int j=0; j<que.size(); ++j)
                for (auto &k : tb[que[j]])
                    if (k != i && !seen[k])
                        que.push_back(k), seen[k] = true;
            if (que.size() < mn || (que.size() == mn && i < mni))
                mn = que.size(), mni = i;
        }
        return mni;
    }
};

struct UnionFind {
    vector<int> id, sz;
    UnionFind(int n): id(n), sz(n, 1) { iota(begin(id), end(id), 0); }
    
    int find(int p) { return id[p] == p ? p : id[p] = find(id[p]); }
    
    void combine(int p, int q) { 
        int i = find(p), j = find(q);
        if (i==j) return;
        id[j] = i;
        sz[i] += sz[j];
    }
    
    int set_size(int p) { return sz[find(p)]; }
};

class Solution {  // Union Find. If a set is connected to more than one initial, it won't be changed by deleting one initial
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        unordered_set i_s(begin(initial), end(initial));
        vector<int> clean;
        for (int i=0; i<n; ++i) if (!i_s.count(i)) clean.push_back(i);
        
        UnionFind uf(n);
        for (auto &i : clean)
            for (auto &j : clean)
                if (i < j && graph[i][j]) uf.combine(i, j);
        
        vector<int> set_inf(n);
        vector<vector<int>> inf_set(n);
        for (auto &i : initial)
            for (auto &j : clean)
                if (graph[i][j]) {
                    int f = uf.find(j);
                    ++set_inf[f];
                    inf_set[i].push_back(f);
                }
        
        int mx = 0, mxi = -1;
        for (auto &i : initial) {
            int t = 1;
            for (auto &j : inf_set[i])
                if (set_inf[j] == 1) t += uf.set_size(j);
            if (t > mx || (t == mx && i < mxi)) mx = t, mxi = i;
        }
        return mxi;
    }
};